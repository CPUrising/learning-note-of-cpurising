# 五子棋 AI 程序使用说明

要使用这个五子棋 AI 程序，核心是通过**标准输入（stdin）向程序发送指令**，并通过**标准输出（stdout）获取程序响应**。以下是详细的使用步骤、输入输出规则及实操示例，完全匹配代码的指令逻辑：

## 一、程序准备：编译与运行

首先需要将代码编译为可执行文件（适配 C++ 编译器，如 GCC、Clang 或 Visual Studio），步骤如下：

### 1. 编译代码



* **GCC/Clang（Windows 用 MinGW、Linux/macOS 直接用）**：

  打开终端，进入代码所在文件夹，执行命令：



```
g++ -o gomoku\_ai gomoku\_ai.cpp -std=c++11  # 生成可执行文件gomoku\_ai
```



* **Visual Studio**：

  新建 “空项目”，添加代码文件，设置为 “控制台应用”，直接编译运行（需关闭安全检查，匹配代码开头`#define _CRT_SECURE_NO_WARNINGS`）。

### 2. 运行程序

编译成功后，运行可执行文件（如`./gomoku_ai`或`gomoku_ai.exe`），程序会进入**指令监听状态**，等待你从标准输入发送命令。

## 二、核心输入输出规则（必看）

程序严格按照固定指令格式交互，输入需是**纯文本命令（每行 1 条）**，输出是程序的响应（如`OK`、落子坐标或调试信息）。

### 1. 关键指令与输入输出对应表



| 输入指令（你发送给程序）       | 指令含义                             | 程序输出（你接收的响应）               | 注意事项                          |
| ------------------ | -------------------------------- | -------------------------- | ----------------------------- |
| `START [color]`    | 初始化游戏，指定 AI 执子颜色（1 = 黑，2 = 白）    | `OK`                       | 必须是第 1 条指令，1 秒内必须响应`OK`       |
| `PLACE X Y`        | 告知 AI：对手在 (X,Y) 落子（坐标 0\~11）     | 无输出（仅内部更新棋盘）               | X = 行、Y = 列，需是棋盘空位，否则 AI 标记无效 |
| `TURN`             | 告知 AI：轮到它落子                      | `X Y`（AI 计算的落子坐标，0\~11）    | 2 秒内必须输出坐标，否则判负               |
| `END [winner]`     | 游戏结束，指定获胜方（0 = 平局，1 = 黑胜，2 = 白胜） | 无输出（程序可自行退出）               | 可选指令，平台会强制关闭程序                |
| `LIBERTY_STEP`     | 开启调试模式（可视化棋盘、手动操作）               | 欢迎信息（`WELCOME TO LIBERTY`） | 仅调试用，开启后支持其他调试指令              |
| `SHOW`（调试模式下）      | 显示当前棋盘状态                         | 12×12 棋盘（含行号列号、棋子位置）       | 需先执行`LIBERTY_STEP`开启调试        |
| `CRACK X Y`（调试模式下） | 手动替 AI 在 (X,Y) 落子                | 无输出（仅更新棋盘，可通过`SHOW`查看）     | 调试用，跳过 AI 计算                  |
| `ERASE X Y`（调试模式下） | 擦除 (X,Y) 位置的棋子                   | 无输出（仅更新棋盘，可通过`SHOW`查看）     | 调试用，用于修正错误落子                  |
| `LIMIT`（调试模式下）     | 检查 AI 落子时间是否合规（≤1900ms / 步）      | 时间检查结果（成功 / 失败提示）          | 调试用，验证程序是否超时                  |

### 2. 坐标规则（重点！避免无效落子）



* 棋盘是**12×12 网格**，坐标`(X,Y)`中：


  * `X` = 行号（0\~11，从上到下）；

  * `Y` = 列号（0\~11，从左到右）；

  * 示例：中心位置是`(5,5)`、`(5,6)`、`(6,5)`、`(6,6)`。

* 输入`PLACE X Y`或`CRACK X Y`时，必须确保`X`和`Y`在 0\~11 之间，且该位置是**空位**（否则 AI 会标记为 “无效落子”，不更新棋盘）。

## 三、实操示例：完整游戏流程

以下是 “AI 执黑（1）vs 你执白（2）” 的完整交互过程，包含输入输出的具体内容：

### 步骤 1：启动游戏（初始化）



* 你输入（发送指令）：



```
START 1
```



* 程序输出（响应）：



```
OK
```



* 说明：AI 已初始化，执黑棋（1），棋盘清空。

### 步骤 2：开启调试模式（可选，可视化棋盘）



* 你输入：



```
LIBERTY\_STEP
```



* 程序输出：



```
&#x20;  WELCOME TO LIBERTY    &#x20;
```



* 说明：调试模式开启，后续可使用`SHOW`查看棋盘。

### 步骤 3：你（白棋）落子，告知 AI



* 你在`(5,5)`落子（白棋 2），输入：



```
PLACE 5 5
```



* 程序输出：无（仅内部更新棋盘，将`(5,5)`设为白棋）。

* （调试用）输入`SHOW`查看棋盘，程序会输出：



```
&#x20;      0        1        2        3        4        5        6        7        8        9       10       11&#x20;

&#x20; +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+

0 |        |        |        |        |        |        |        |        |        |        |        |        |

&#x20; +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+

1 |        |        |        |        |        |        |        |        |        |        |        |        |

&#x20; +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+

...（中间行省略）...

5 |        |        |        |        |        |   ○   |        |        |        |        |        |        |  # (5,5)是你的白棋

&#x20; +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+

...（后续行省略）...
```

### 步骤 4：轮到 AI 落子（黑棋）



* 你输入指令，让 AI 落子：



```
TURN
```



* 程序输出（AI 计算的落子坐标，示例为`5,6`）：



```
5 6
```



* 说明：AI 在`(5,6)`落子（黑棋 1），并更新棋盘。

* （调试用）输入`SHOW`，可看到`(5,6)`位置显示`●`（黑棋）。

### 步骤 5：重复落子，直到结束



* 你继续落子：输入`PLACE X Y`（如`PLACE 5 6`，但`(5,6)`已被 AI 占用，AI 会输出调试信息`Invalid enemy move at (5,6)`，不更新棋盘）；

* 再让 AI 落子：输入`TURN`，程序输出新坐标；

* 直到某一方形成五子连珠，输入`END [winner]`（如`END 1`表示 AI 黑棋胜），程序结束。

## 四、常见问题与注意事项

### 1. 程序无响应？



* 检查输入格式：确保每条指令**独占一行**，无多余空格（如`START 1`不能写成`START   1`或`START\n1`）；

* 避免阻塞：`scanf`会等待输入，若程序卡住，需确认是否漏发指令（如`START`后未等`OK`就发`TURN`）。

### 2. AI 输出无效坐标？



* 检查棋盘是否已满（12×12=144 格），满棋后 AI 无有效位置，可能输出`-1 -1`（代码中保底逻辑）；

* 确保`PLACE`指令的坐标是空位，若对手落子在已有棋子的位置，AI 不会更新棋盘，后续`TURN`可能计算错误。

### 3. 调试模式不显示棋盘？



* 必须先输入`LIBERTY_STEP`开启调试模式，再输入`SHOW`；

* 部分终端可能不支持中文符号，可忽略棋子显示（`●`/`○`），通过行号列号判断位置。

### 4. 超时问题？



* 代码中 AI 落子限制为**1900ms / 步**，若输入`LIMIT`检查失败，需减少`MAX_DEPTH`（当前 7 层，可改为 5 层），降低搜索复杂度。

## 五、平台评测场景适配

若提交到课程评测平台，无需手动输入指令，平台会自动发送`START`、`PLACE`、`TURN`、`END`等指令，你的程序只需确保：



1. 输入输出格式严格匹配（无多余字符，`fflush(stdout)`强制刷新输出，避免延迟）；

2. 单步`TURN`响应≤2 秒，总用时≤90 秒（代码中`TIME_LIMIT=1900`已预留冗余）；

3. 不使用文件读写、多线程等禁用函数（代码已符合，仅用标准输入输出）。

按照以上步骤操作，即可正常使用程序进行人机对战或平台评测。

> （注：文档部分内容可能由 AI 生成）